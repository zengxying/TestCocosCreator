/**
 * 每个象限的flag
 */
const QuadFlag = [1 << 0, 1 << 1, 1 << 2, 1 << 3];
/**
 * 混合象限的flag
 * [1象限+2象限, 2象限+3象限, 3象限+4象限, 4象限+1象限]
 */
// const QuadFlagMix = [QuadFlag[0] | QuadFlag[1], QuadFlag[1] | QuadFlag[2], QuadFlag[2] | QuadFlag[3], QuadFlag[0] | QuadFlag[3]];

/**
 * uuid制造器
 * 永远产生正整数(不含0)
 */
class UuidMaker {
    private static _inst: UuidMaker = null;
    static get inst() {
        if (!this._inst) this._inst = new UuidMaker();
        return this._inst;
    }

    private index = 0;
    public create() {
        if (++this.index > 1E10) {
            this.index = 1;
        }
        return this.index;
    }
}

export interface IQuadRect<T = unknown> {
    readonly uuid: number;

    readonly width: number;
    readonly height: number;

    readonly xMin: number;
    readonly yMin: number;
    readonly xMid: number;
    readonly yMid: number;
    readonly xMax: number;
    readonly yMax: number;

    readonly target: T
}

class QuadRect<T = unknown> implements IQuadRect<T> {
    public uuid: number = 0;

    public width: number = 0;
    public height: number = 0;

    public xMin: number = 0;
    public yMin: number = 0;

    public xMid: number = 0;
    public yMid: number = 0;

    public xMax: number = 0;
    public yMax: number = 0;

    public target: T;

    constructor(x: number, y: number, w: number, h: number, target: T = null) {
        this.target = target;
        this.uuid = UuidMaker.inst.create();
        this.setPosAndSize(x, y, w, h);
    }

    public setPosAndSize(x: number, y: number, w: number, h: number) {
        this.xMid = x;
        this.yMid = y;
        this.setSize(w, h);
    }

    public setPosition(x: number, y: number) {
        this.xMid = x;
        this.yMid = y;

        this.xMin = x - this.width / 2;
        this.yMin = y - this.height / 2;

        this.xMax = this.xMin + this.width;
        this.yMax = this.yMin + this.height;
    }

    public setSize(w: number, h: number) {
        this.width = w;
        this.height = h;

        this.xMin = this.xMid - w / 2;
        this.yMin = this.yMid - h / 2;

        this.xMax = this.xMin + w;
        this.yMax = this.yMin + h;
    }

    /**
     * 测试自身矩形是否与rect矩形相交
     */
    public intersect(rect: QuadRect) {
        return rect.xMax >= this.xMin &&
            rect.xMin <= this.xMax &&
            rect.yMax >= this.yMin &&
            rect.yMin <= this.yMax;
    }

    /**
     * 测试自身矩形是否包含rect矩形
     */
    public contain(rect: QuadRect) {
        return this.xMin <= rect.xMin &&
            this.xMax >= rect.xMax &&
            this.yMin <= rect.yMin &&
            this.yMax >= rect.yMax;
    }
}

class QuadNode<T> {
    public value: QuadRect<T> = null;
    public last: QuadNode<T> = null;
    public next: QuadNode<T> = null;

    constructor(value: QuadRect<T>) {
        this.value = value;
    }

    public concat(next: QuadNode<T>) {
        this.next = next;
        if (next) next.last = this;
    }

    public disConcat() {
        this.last.concat(this.next);
        this.last = this.next = null;
    }
}

class QuadList<T> {
    readonly head = new QuadNode<T>(null);

    public push(node: QuadNode<T>) {
        if (this.head.next === null) {
            this.head.concat(node);
        } else {
            let body = this.head;
            let next = body.next;
            const nodeMinx = node.value.xMin;
            while (true) {
                if (next === null) {
                    body.concat(node);
                    break;
                } else if (nodeMinx < next.value.xMin) {
                    node.concat(next);
                    body.concat(node);
                    break;
                }
                body = next;
                next = body.next;
            }
        }
    }

    public clear() {
        this.head.next = null;
    }
}

class QuadSubTree<T> {
    protected maxLevel: number = 4;

    protected level: number = 0;
    protected bounds: QuadRect = null;
    protected rectList: QuadList<T> = new QuadList();
    protected childArray: QuadSubTree<T>[] = [];
    protected parent: QuadSubTree<T> = null;

    constructor(bounds: QuadRect<T>, max_levels: number, level: number = 0, parent: QuadSubTree<T> = null) {
        this.level = level;
        this.bounds = bounds;
        this.parent = parent;
        this.maxLevel = max_levels;
    }

    /**
     * 分裂
     */
    protected split() {
        if (!this.childArray.length) {
            const x = this.bounds.xMid;
            const y = this.bounds.yMid;
            const w = this.bounds.width / 2;
            const h = this.bounds.height / 2;
            const w2 = this.bounds.width / 4;
            const h2 = this.bounds.width / 4;
            const level = this.level + 1;
            this.childArray.push(
                new QuadSubTree<T>(new QuadRect<T>(x + w2, y + h2, w, h), this.maxLevel, level, this),
                new QuadSubTree<T>(new QuadRect<T>(x - w2, y + h2, w, h), this.maxLevel, level, this),
                new QuadSubTree<T>(new QuadRect<T>(x - w2, y - h2, w, h), this.maxLevel, level, this),
                new QuadSubTree<T>(new QuadRect<T>(x + w2, y - h2, w, h), this.maxLevel, level, this)
            );
        }
    }

    /**
     * 获得所在象限
     */
    protected getQuadFlags(rect: QuadRect<T>): number {
        let flags = 0;

        const startInLeft = rect.xMin < this.bounds.xMid,
            startInTop = rect.yMax > this.bounds.yMid,
            endInRight = rect.xMax > this.bounds.xMid,
            endInBottom = rect.yMin < this.bounds.yMid;

        if (startInTop && endInRight) {
            flags |= QuadFlag[0];
        }
        if (startInTop && startInLeft) {
            flags |= QuadFlag[1];
        }
        if (startInLeft && endInBottom) {
            flags |= QuadFlag[2];
        }
        if (endInRight && endInBottom) {
            flags |= QuadFlag[3];
        }

        return flags;
    }

    /**
     * 插入
     */
    public insert(node: QuadNode<T>): QuadSubTree<T> {
        // 自身是最后一层，直接存储在自身
        if (this.level === this.maxLevel) {
            this.rectList.push(node);
            return this;
        }

        // 获取与哪些象限相交
        const quadFlags = this.getQuadFlags(node.value);
        // 子集index
        const index = QuadFlag.indexOf(quadFlags);

        // 相交数为0或多于1个，直接存储在自身
        if (index === -1) {
            this.rectList.push(node);
            return this;
        }

        // 分割子象限
        if (this.childArray.length === 0) {
            this.split();
        }

        // 插入到子象限中
        return this.childArray[index].insert(node);
    }

    /**
     * 反向插入(从子树开始向上查询)
     */
    public insertReverse(node: QuadNode<T>): QuadSubTree<T> {
        if (this.bounds.contain(node.value)) {
            return this.insert(node);
        }
        if (this.parent) {
            return this.parent.insertReverse(node);
        }
        return this.insert(node);
    }

    /**
     * 检索(不检查子树)
     */
    private retrieveSelf(out: IQuadRect<T>[], rect: QuadRect<T>, multiple = false): number {
        const rectUUID = rect.uuid;
        const rectXMax = rect.xMax;

        // 遍历查询
        for (let node = this.rectList.head.next, otherRect: QuadRect<T> = null; node; node = node.next) {
            otherRect = node.value;
            if (rectXMax < otherRect.xMin) break;
            if (rectUUID === otherRect.uuid) continue;
            if (!rect.intersect(otherRect)) continue;
            out.push(otherRect);
            if (multiple === false) return;
        }
    }

    /**
     * 检索(会检查子树)
     */
    public retrieve(out: IQuadRect<T>[], rect: QuadRect<T>, multiple = false): IQuadRect<T>[] {
        this.retrieveSelf(out, rect);

        if (multiple === false && out.length > 0) {
            return out;
        }

        // 自身是最后一层，没有子节点
        if (this.level === this.maxLevel || this.childArray.length === 0) {
            return out;
        }

        // 都不相交
        // if (quadFlags === 0) {
        //     console.error('rect不与tree中的任何一个象限相交，这个情况不该发生');
        //     return out;
        // }

        // 获取rect与哪些象限相交
        const quadFlags = this.getQuadFlags(rect);
        // 组合子象限数据
        for (let index = 0; index < QuadFlag.length; index++) {
            if (!(QuadFlag[index] & quadFlags)) continue;
            this.childArray[index].retrieve(out, rect);
            if (multiple === false && out.length > 0) break;
        }

        return out;
    }

    /**
     * 反向检索(供子树调用的内部函数)
     */
    private retrieveParent(out: IQuadRect<T>[], rect: QuadRect<T>, multiple = false): IQuadRect<T>[] {
        if (this.parent) {
            this.parent.retrieveParent(out, rect, multiple);
            if (multiple === false && out.length > 0) {
                return out;
            }
        }
        this.retrieveSelf(out, rect, multiple);
        return out;
    }

    /**
     * 反向检索(从子树开始向下和上查询)
     */
    public retrieveReverse(out: IQuadRect<T>[], rect: QuadRect<T>, multiple = false): IQuadRect<T>[] {
        if (this.parent) {
            this.parent.retrieveParent(out, rect, multiple);
            if (multiple === false && out.length > 0) {
                return out;
            }
        }
        return this.retrieve(out, rect, multiple);
    }

    /**
     * 清空
     */
    public clear() {
        for (let i = this.childArray.length - 1; i >= 0; i--) {
            this.childArray[i].clear();
        }

        this.rectList.clear();
        this.childArray.length = 0;
    }
}

export class QuadTree<T = unknown> {
    private quadTree: QuadSubTree<T> = null;

    private nodeCache: QuadNode<T>[] = [];
    private rectCache: QuadRect<T>[] = [];
    private rid2Node: Map<number, QuadNode<T>> = new Map();
    private rid2Tree: Map<number, QuadSubTree<T>> = new Map();

    private getRect(x: number, y: number, width: number, height: number, target: T = null) {
        if (this.rectCache.length) {
            const rect = this.rectCache.pop();
            rect.target = target;
            rect.setPosAndSize(x, y, width, height);
            return rect;
        } else {
            return new QuadRect<T>(x, y, width, height, target);
        }
    }

    private putRect(rect: QuadRect<T>) {
        rect.target = null;
        this.rectCache.push(rect);
    }

    private getNode(rect: QuadRect<T>) {
        if (this.nodeCache.length) {
            const node = this.nodeCache.pop();
            node.value = rect;
            return node;
        } else {
            return new QuadNode(rect);
        }
    }

    private putNode(node: QuadNode<T>) {
        node.value = null;
        this.nodeCache.push(node);
    }

    /**
     * 创建
     * @param bounds.x 中心点x坐标
     * @param bounds.y 中心点y坐标
     * @param bounds.width     宽
     * @param bounds.height    高
     * @param maxLevels 最大深度
     */
    constructor(bounds: { x: number, y: number, width: number, height: number }, max_levels: number = 4) {
        const rect = new QuadRect<T>(bounds.x, bounds.y, bounds.width, bounds.height);
        this.quadTree = new QuadSubTree<T>(rect, max_levels);
    }

    /**
     * 插入一个rect
     * @param position.x 中心点x坐标
     * @param position.y 中心点y坐标
     * @param size.width         宽
     * @param size.height        高
     * @returns uuid(从1开始)
     */
    public insert(position: { x: number, y: number }, size: { width: number, height: number }, target: T = null): number {
        const rect = this.getRect(position.x, position.y, size.width, size.height, target);
        const node = this.getNode(rect);

        const tree = this.quadTree.insert(node);
        this.rid2Node.set(rect.uuid, node);
        this.rid2Tree.set(rect.uuid, tree);
        return rect.uuid;
    }

    private disConcat(uuid: number): QuadNode<T> {
        const node = this.rid2Node.get(uuid);
        if (!node) return null;

        node.disConcat();
        return node;
    }

    /**
     * 移除一个rect
     */
    public remove(uuid: number): boolean {
        const node = this.disConcat(uuid);
        if (!node) return false;

        this.rid2Node.delete(uuid);
        this.rid2Tree.delete(uuid);
        this.putRect(node.value);
        this.putNode(node);

        return true;
    }

    /**
     * 刷新一个rect
     * @param uuid 
     * @param bounds.x 中心点x坐标
     * @param bounds.y 中心点y坐标
     * @param bounds.width     宽
     * @param bounds.height    高
     * @returns 
     */
    public refresh(uuid: number, bounds: { x: number, y: number, width: number, height: number }): boolean {
        const node = this.disConcat(uuid);
        if (!node) return false;

        // 设置
        const rect = node.value;
        rect.setPosAndSize(bounds.x, bounds.y, bounds.width, bounds.height);

        const oldTree = this.rid2Tree.get(uuid);
        const newTree = oldTree.insertReverse(node);
        if (oldTree !== newTree) {
            this.rid2Tree.set(uuid, newTree);
        }
        return true;
    }

    /**
     * 刷新一个rect
     * @param uuid 
     * @param bounds.x 中心点x坐标
     * @param bounds.y 中心点y坐标
     * @returns 
     */
    public refreshPosition(uuid: number, position: { x: number, y: number }): boolean {
        const node = this.disConcat(uuid);
        if (!node) return false;

        // 设置
        const rect = node.value;
        rect.setPosition(position.x, position.y);

        const oldTree = this.rid2Tree.get(uuid);
        const newTree = oldTree.insertReverse(node);
        if (oldTree !== newTree) {
            this.rid2Tree.set(uuid, newTree);
        }
        return true;
    }

    /**
     * 刷新一个rect
     * @param uuid 
     * @param bounds.width     宽
     * @param bounds.height    高
     * @returns 
     */
    public refreshSize(uuid: number, size: { width: number, height: number }): boolean {
        const node = this.disConcat(uuid);
        if (!node) return false;

        // 设置
        const rect = node.value;
        rect.setSize(size.width, size.height);

        const oldTree = this.rid2Tree.get(uuid);
        const newTree = oldTree.insertReverse(node);
        if (oldTree !== newTree) {
            this.rid2Tree.set(uuid, newTree);
        }
        return true;
    }

    /**
     * 检索碰撞数组
     */
    public retrieve(out: IQuadRect<T>[], uuid: number, multiple = false): IQuadRect<T>[] {
        const node = this.rid2Node.get(uuid);
        if (!node) return out;

        const tree = this.rid2Tree.get(uuid);
        if (multiple) {
            return tree.retrieveReverse(out, node.value, multiple);
        }

        tree.retrieveReverse(out, node.value, multiple);
        return out;
    }

    /**
     * 根据某个范围检索碰撞数组
     * @param bounds.x 中心点x坐标
     * @param bounds.y 中心点y坐标
     * @param bounds.width     宽
     * @param bounds.height    高
     */
    public retrieveBounds(out: IQuadRect<T>[], bounds: { x: number, y: number, width: number, height: number }, multiple = false): IQuadRect<T>[] {
        const rect = this.getRect(bounds.x, bounds.y, bounds.width, bounds.height);
        if (multiple) {
            this.quadTree.retrieve(out, rect, multiple);
        } else {
            this.quadTree.retrieve(out, rect, multiple);
        }
        this.putRect(rect);
        return out;
    }

    /**
     * 清理内存
     */
    public clear() {
        this.quadTree.clear();
        this.rid2Node.clear();
        this.rid2Tree.clear();
        this.nodeCache.length = 0;
        this.rectCache.length = 0;
    }
}