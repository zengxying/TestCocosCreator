import { Asset, assetManager, Font, instantiate, isValid, Label, Prefab, sp, Sprite, SpriteFrame } from 'cc';
import { RenderComponent, RenderType } from '../component/RenderComponent';

export class RenderSystem {
    private static _inst: RenderSystem = null;
    static get inst() {
        if (this._inst) return this._inst;
        this._inst = new RenderSystem();
        return this._inst;
    }

    public innerExecute(renderComp: RenderComponent) {
        if (renderComp.renderType === RenderType.Texture) {
            this.refreshTexture(renderComp);
            RenderComponent.systemHandle(renderComp);
        } else if (renderComp.renderType === RenderType.Spine) {
            this.refreshSpine(renderComp);
            RenderComponent.systemHandle(renderComp);
        } else if (renderComp.renderType === RenderType.Label) {
            this.refreshString(renderComp);
            RenderComponent.systemHandle(renderComp);
        } else if (renderComp.renderType === RenderType.Prefab) {
            this.refreshPrefab(renderComp);
            RenderComponent.systemHandle(renderComp);
        }

        this.loadTaskList.splice(0, 5).forEach(task => task());
    }

    private loadTaskList: Function[] = [];
    private loadRenderRes(render: RenderComponent, callback: (asset: Asset) => any) {
        const renderUrl = render.renderUrl;
        const renderType = render.renderType;

        const [bundle, path] = this.getBundleAndPathFromUrl(renderUrl);
        this.loadTaskList.push(() => {
            assetManager.loadBundle(bundle, (error, bundle) => {
                if (renderUrl !== render.renderUrl) return;
                if (renderType !== render.renderType) return;

                if (error) {
                    callback(null);
                    return this.error(error);
                }

                const AssetType: typeof Asset = renderType === RenderType.Texture ? SpriteFrame : (
                    renderType === RenderType.Spine ? sp.SkeletonData : (
                        renderType === RenderType.Label ? Font : Prefab
                    )
                );

                if (path[path.length - 1] === '/') {
                    bundle.loadDir(path, AssetType, (error, assets) => {
                        if (renderUrl !== render.renderUrl) return;
                        if (renderType !== render.renderType) return;

                        if (error) {
                            callback(null);
                            return this.error(error);
                        }

                        callback(assets[0]);
                    });
                } else {
                    bundle.load(path, AssetType, (error, asset) => {
                        if (renderUrl !== render.renderUrl) return;
                        if (renderType !== render.renderType) return;
                        if (error) {
                            callback(null);
                            return this.error(error);
                        }

                        callback(asset);
                    });
                }
            });
        });
    }

    private error(...args: any[]) {
        console.error('[RenderSystem] [error]', ...args);
    }

    private setSpineAnimation(spine: sp.Skeleton, spineAnimation: string) {
        const anis = spineAnimation.split(',');
        spine.animation = anis[0];
        if (anis.length > 0) {
            let index = 1;
            spine.setCompleteListener(() => {
                if (index < anis.length) {
                    spine.animation = anis[index++];
                }
                if (index >= anis.length) {
                    spine.setCompleteListener(null);
                }
            });
        } else {
            spine.setCompleteListener(null);
        }
    }

    private getBundleAndPathFromUrl(url: string) {
        const arr = url.split(':');
        if (arr.length >= 2) {
            return arr.slice(0, 2);
        }
        return ['resources', arr[0]];
    }

    private refreshSpine(renderComp: RenderComponent) {
        renderComp.renderNode.destroyAllChildren();
        renderComp.renderNode.getComponent(Sprite)?.destroy();
        renderComp.renderNode.getComponent(Label)?.destroy();
        const spine = renderComp.renderNode.getComponent(sp.Skeleton) || renderComp.renderNode.addComponent(sp.Skeleton);

        // 下载新的spine
        if (renderComp.refreshRender) {
            if (renderComp.spineRenderData) {
                spine.skeletonData = renderComp.spineRenderData;
                spine.loop = renderComp.spineLoop;
                spine.paused = renderComp.spinePaused;
                spine.timeScale = renderComp.spineTimeScale;
                spine.premultipliedAlpha = renderComp.spineAlpha;

                const skin = renderComp.spineSkin || spine['defaultSkin'];
                if (skin) spine.setSkin(skin);

                this.setSpineAnimation(spine, renderComp.spineAnimation);
                RenderComponent.callRenderChanged(renderComp);
            } else if (renderComp.renderUrl) {
                spine.skeletonData = null;
                this.loadRenderRes(renderComp, (data: sp.SkeletonData) => {
                    if (!data) return;
                    if (!isValid(spine)) return;
                    spine.skeletonData = data;
                    spine.loop = renderComp.spineLoop;
                    spine.paused = renderComp.spinePaused;
                    spine.timeScale = renderComp.spineTimeScale;
                    spine.premultipliedAlpha = renderComp.spineAlpha;

                    const skin = renderComp.spineSkin || spine['defaultSkin'];
                    if (skin) spine.setSkin(skin);

                    this.setSpineAnimation(spine, renderComp.spineAnimation);
                    RenderComponent.callRenderChanged(renderComp);
                });
            } else {
                spine.skeletonData = null;
            }
        } else if (isValid(spine) && spine.skeletonData) {
            if (renderComp.refreshRenderAttr) {
                spine.loop = renderComp.spineLoop;
                spine.paused = renderComp.spinePaused;
                spine.timeScale = renderComp.spineTimeScale;
                spine.premultipliedAlpha = renderComp.spineAlpha;
            }
            if (renderComp.refreshSpineSkin) {
                const skin = renderComp.spineSkin || spine['defaultSkin'];
                if (skin) spine.setSkin(skin);
            }
            if (renderComp.refreshSpineAnimation) {
                this.setSpineAnimation(spine, renderComp.spineAnimation);
            }
        }
    }

    private refreshTexture(renderComp: RenderComponent) {
        renderComp.renderNode.destroyAllChildren();
        renderComp.renderNode.getComponent(sp.Skeleton)?.destroy();
        renderComp.renderNode.getComponent(Label)?.destroy();
        const sprite = renderComp.renderNode.getComponent(Sprite) || renderComp.renderNode.addComponent(Sprite);

        if (!renderComp.renderUrl) {
            sprite.spriteFrame = null;
            return;
        }

        // 下载新的图片
        if (renderComp.refreshRender) {
            if (renderComp.texRenderData) {
                sprite.type = renderComp.texRenderType;
                sprite.sizeMode = renderComp.texSizeMode;
                sprite.spriteFrame = renderComp.texRenderData;
                RenderComponent.callRenderChanged(renderComp);
            } else if (renderComp.renderUrl) {
                sprite.spriteFrame = null;
                this.loadRenderRes(renderComp, (frame: SpriteFrame) => {
                    if (!frame) return;
                    if (!isValid(sprite)) return;
                    sprite.type = renderComp.texRenderType;
                    sprite.sizeMode = renderComp.texSizeMode;
                    sprite.spriteFrame = frame;
                    RenderComponent.callRenderChanged(renderComp);
                });
            } else {
                sprite.spriteFrame = null;
            }
        } else if (isValid(sprite) && sprite.spriteFrame) {
            if (renderComp.refreshRenderAttr) {
                sprite.type = renderComp.texRenderType;
                sprite.sizeMode = renderComp.texSizeMode;
            }
        }
    }

    private refreshString(renderComp: RenderComponent) {
        renderComp.renderNode.destroyAllChildren();
        renderComp.renderNode.getComponent(sp.Skeleton)?.destroy();
        renderComp.renderNode.getComponent(Sprite)?.destroy();
        const label = renderComp.renderNode.getComponent(Label) || renderComp.renderNode.addComponent(Label);

        if (isValid(label)) {
            if (renderComp.refreshRenderAttr) {
                label.fontSize = renderComp.labelFontSize;
                label.lineHeight = renderComp.labelLineHeight;
                label.horizontalAlign = renderComp.labelHorizontalAlignment;
                label.verticalAlign = renderComp.labelVerticalAlignment;
                label.enableWrapText = renderComp.labelWrap;
                label.cacheMode = renderComp.labelCacheMode;
                label.overflow = renderComp.labelOverflow;
            }
            if (renderComp.refreshLabelString) {
                label.string = renderComp.labelRenderData;
            }
        }

        if (renderComp.refreshRender) {
            if (renderComp.renderUrl) {
                this.loadRenderRes(renderComp, (font: Font) => {
                    if (!font) return;
                    label.font = font;
                    label.useSystemFont = false;
                    RenderComponent.callRenderChanged(renderComp);
                });
            } else {
                label.useSystemFont = true;
                RenderComponent.callRenderChanged(renderComp);
            }
        }
    }

    private refreshPrefab(renderComp: RenderComponent) {
        renderComp.renderNode.getComponent(sp.Skeleton)?.destroy();
        renderComp.renderNode.getComponent(Sprite)?.destroy();
        renderComp.renderNode.getComponent(Label)?.destroy();

        // 下载新的预制体
        if (renderComp.refreshRender) {
            renderComp.renderNode.destroyAllChildren();
            if (renderComp.prefabRenderData) {
                const node = instantiate(renderComp.prefabRenderData);
                node.parent = renderComp.renderNode;
                RenderComponent.callRenderChanged(renderComp);
            } else if (renderComp.renderUrl) {
                this.loadRenderRes(renderComp, (prefab: Prefab) => {
                    if (!prefab) return;
                    if (!isValid(renderComp)) return;
                    if (!isValid(renderComp.renderNode)) return;
                    const node = instantiate(prefab);
                    node.parent = renderComp.renderNode;
                    RenderComponent.callRenderChanged(renderComp);
                });
            }
        }
    }
}
