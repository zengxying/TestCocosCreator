import { Node } from 'cc';
import { DEV, EDITOR } from 'cc/env';
import { MoveComponent } from './common/component/MoveComponent';
import { NodeComponent } from './common/component/NodeComponent';
import { RenderComponent } from './common/component/RenderComponent';
import { TimerComponent } from './common/component/TimerComponent';
import { TweenComponent } from './common/component/TweenComponent';
import { AttrSystem } from './common/system/AttrSystem';
import { MoveSystem } from './common/system/MoveSystem';
import { RenderSystem } from './common/system/RenderSystem';
import { EcsEntity } from './ecs/EcsEntity';
import { EcsSystem } from './ecs/EcsSystem';
import { EcsBase, EcsBaseEntity, IComponent, IComponentName, IECS, IECSManager, IEntity, IEntityUUID, IFilter, IFlag, ISingleton, ISystem, ITypeofComponent, ITypeofEntity, ITypeofSingleton, ITypeofSystem, classManager, componentCache, componentUuidMaker, entityCache, entityUuidMaker, flagManager, singletonUuidMaker, systemUuidMaker } from './util/EcsObject';
import { CustomArray } from './util/EcsUtils';

/**
 * 组件管理器
 */
class ComponentManager {
    private components: Map<IComponentName, CustomArray<IComponent>> = new Map();

    private getOrCreateComps(name: IComponentName) {
        if (!this.components.has(name)) {
            this.components.set(name, new CustomArray<IComponent>());
        }
        return this.components.get(name);
    }

    /**
     * 添加一个组件名对应的实体
     */
    addComponent(comName: IComponentName, comp: IComponent) {
        if (!comName) return;

        // 添加当前
        this.getOrCreateComps(comName).add(comp);

        // 添加基类
        this.addComponent(classManager.getSuperName(comName), comp);
    }

    /**
     * 移除一个组件名对应的实体
     */
    removeComponent(comName: IComponentName, comp: IComponent) {
        if (!comName) return;

        // 删除当前
        if (!this.components.has(comName)) return;
        this.getOrCreateComps(comName).remove(comp);

        // 删除基类
        this.removeComponent(classManager.getSuperName(comName), comp);
    }

    /**
     * 根据组件名获取实体列表，可能不存在
     */
    getComponents(comName: IComponentName) {
        return this.components.get(comName) || null;
    }

    clear() {
        this.components.forEach(value => value.clear());
        this.components.clear();
    }
}

/**
 * 实体管理器
 */
class EntityManager {
    private entities: Map<IEntityUUID, IEntity> = new Map();

    has(uuid: IEntityUUID) {
        return this.entities.get(uuid) || null;
    }

    add(entity: IEntity) {
        this.entities.set(entity.uuid, entity);
    }

    remove(entity: IEntity) {
        return this.entities.delete(entity.uuid);
    }

    get(uuid: IEntityUUID) {
        return this.entities.get(uuid) || null;
    }

    getAll(out: IEntity[]) {
        this.entities.forEach(entity => out.push(entity));
        return out;
    }

    each(callback: (value: IEntity) => void) {
        this.entities.forEach(callback);
    }

    clear() {
        this.entities.clear();
    }
}

/**
 * 系统管理器
 */
class SystemManager {
    private systems: ISystem[] = [];

    /**
     * 添加系统
     */
    add(system: ISystem) {
        this.systems.push(system);
    }

    get(System: ITypeofSystem) {
        const index = this.systems.findIndex(system => system.ecsName === System.ecsName);
        return this.systems[index];
    }

    /**
     * 移除系统
     */
    remove(System: ITypeofSystem) {
        const index = this.systems.findIndex(system => system.ecsName === System.ecsName);
        if (index >= 0) {
            return this.systems.splice(index, 1)[0] || null;
        }
        return null;
    }

    /**
     * 清空所有
     */
    clear() {
        this.systems.length = 0;
    }

    each(callback: (value: ISystem) => void) {
        this.systems.forEach(callback);
    }

    get size() {
        return this.systems.length;
    }
}

class Filter implements IFilter {
    static check(entity: IEntity, filter: Filter) {
        return filter.pipeline.every(handle => handle(entity));
    }

    static query(entityManager: EntityManager, componentManager: ComponentManager, filter: Filter) {
        let result: IEntity[] = [];
        if (!filter) return result;

        const filterComp = (comp: IComponent) => {
            if (!comp.enabled) return;
            if (!comp.entity.enabled) return;
            if (result.indexOf(comp.entity) >= 0) return;
            result.push(comp.entity);
        };

        // 优先验证any
        if (filter.anyList.length !== 0) {
            filter.anyList.forEach(comName => {
                componentManager.getComponents(comName)?.forEach(filterComp);
            });
            if (result.length === 0) return result;
        }

        // 其次验证include
        if (result.length === 0 && filter.include) {
            componentManager.getComponents(filter.include)?.forEach(filterComp);
            if (result.length === 0) return result;
        }

        // 还查询不到，获取所有
        if (result.length === 0 && filter.hasExclude) {
            entityManager.each((entity) => {
                if (!entity.enabled) return;
                result.push(entity);
            });
        }

        // 没有实体
        if (result.length === 0) return result;

        return result.filter(entity => this.check(entity, filter));
    }

    static find(entityManager: EntityManager, componentManager: ComponentManager, filter: Filter) {
        if (!filter) return null;

        // 优先验证any
        if (filter.anyList.length) {
            for (let index = 0, length = filter.anyList.length; index < length; index++) {
                const comName = filter.anyList[index];
                const com = componentManager.getComponents(comName)?.find((comp) => {
                    if (!comp.enabled) return false;
                    if (!comp.entity.enabled) return false;
                    return Filter.check(comp.entity, filter);
                });
                // 只要有任何一个any符合筛选条件，就返回
                if (com) return com.entity;
            }
            return null;
        }

        let result: IEntity[] = [];

        // 其次验证include
        if (filter.include) {
            componentManager.getComponents(filter.include)?.forEach((comp) => {
                if (!comp.enabled) return;
                if (!comp.entity.enabled) return;
                if (result.indexOf(comp.entity) >= 0) return;
                result.push(comp.entity);
            });
            if (result.length === 0) return null;
        }

        // 获取所有
        if (result.length === 0 && filter.hasExclude) {
            entityManager.each((entity) => {
                if (!entity.enabled) return;
                result.push(entity);
            });
        }

        if (result.length === 0) return null;

        result = result.filter(entity => this.check(entity, filter));

        return result.length > 0 ? result[0] : null;
    }

    private anyList: IComponentName[] = [];
    private include: IComponentName = '';
    private hasExclude: boolean = false;
    private pipeline: ((entity: IEntity) => boolean)[] = [];

    /**
     * 有这些组件中的任何一个
     */
    any(...comps: ITypeofComponent[]) {
        if (comps.length === 0) return this;

        comps.forEach(com => {
            if (this.anyList.indexOf(com.ecsName) >= 0) return;
            this.anyList.push(com.ecsName);
        });

        return this;
    }
    /**
     * 必须包含所有这些组件
     */
    all(...comps: ITypeofComponent[]) {
        if (comps.length === 0) return this;
        if (!this.include) this.include = comps[0].ecsName;

        let flag: IFlag = null;
        this.pipeline.push(function all(entity: IEntity) {
            if (!flag) flag = flagManager.getByNames(comps.map(com => com.ecsName));
            return entity.checkFlagAll(flag);
        });
        return this;
    }
    /**
     * 仅仅只有这些组件
     */
    only(...comps: ITypeofComponent[]) {
        if (comps.length === 0) return this;
        if (!this.include) this.include = comps[0].ecsName;

        let flag: IFlag = null;
        this.pipeline.push(function only(entity: IEntity) {
            if (!flag) flag = flagManager.getByNames(comps.map(com => com.ecsName));
            return entity.checkFlagOnly(flag);
        });
        return this;
    }
    /**
     * 不能包含其中的任何一个组件
     */
    exclude(...comps: ITypeofComponent[]) {
        if (comps.length === 0) return this;
        this.hasExclude = true;

        let flag: IFlag = null;
        this.pipeline.push(function exclude(entity: IEntity) {
            if (!flag) flag = flagManager.getByNames(comps.map(com => com.ecsName));
            return !entity.checkFlagAny(flag);
        });

        return this;
    }
}

/**
 * 过滤条件
 */
export const filter: IFilter = {
    all(...comps: ITypeofComponent[]) {
        return new Filter().all(...comps);
    },
    any(...comps: ITypeofComponent[]) {
        return new Filter().any(...comps);
    },
    only(...comps: ITypeofComponent[]) {
        return new Filter().only(...comps);
    },
    exclude(...comps: ITypeofComponent[]) {
        return new Filter().exclude(...comps);
    }
};

interface ITimerCallback {
    (...args: any[]): false | void
}

class Timer {
    // 回调
    callback: ITimerCallback = null;
    target: any = null;
    // 间隔帧数
    interval = 1;
    // 执行次数 <=0 为无限次
    times = 0;
    // 已执行帧数
    count = 0;

    constructor(callback: ITimerCallback, interval = 1, times = 0, target: any = null) {
        this.callback = callback;
        this.interval = interval;
        this.times = times;
        this.target = target;
    }
}

/**
 * 定时器管理器
 * @example
 * const timer = TimerManager.create();
 * 
 * // 3个step后执行cc.log(1)，再3个step后执行cc.log(1)，共执行两次回调
 * timer.on(() => console.log(1), 3, 2, this)
 * 
 * // 1个step后执行cc.log(1)，只执行1次
 * timer.once(() => console.log(1), this)
 */
class TimerManager {
    static create() {
        return new TimerManager();
    }

    /**基于次数 */
    private timers: Timer[] = [];

    /**
     * 监听
     * @param interval 间隔
     * @param times 次数 <=0 为无限次
     */
    on(callback: ITimerCallback, interval = 1, times = 0, target?: any) {
        this.timers.push(new Timer(callback, interval, times, target));
    }

    /**
     * 监听一次
     */
    once(callback: ITimerCallback, target?: any) {
        this.timers.push(new Timer(callback, 1, 1, target));
    }

    /**
     * 取消监听
     */
    off(callback: ITimerCallback, target?: any) {
        for (let index = this.timers.length - 1; index >= 0; index--) {
            const timer = this.timers[index];
            if (timer.callback === callback && (target ? timer.target === target : true)) {
                this.timers.splice(index, 1);
            }
        }
    }

    /**
     * 迭代一次
     */
    step(args: any[]) {
        for (let index = 0; index < this.timers.length; index++) {
            const timer = this.timers[index];
            if (++timer.count >= timer.interval) {
                const result = timer.callback.apply(timer.target, args);
                if (result === false || (timer.times > 0 && --timer.times <= 0)) {
                    this.timers.splice(index--, 1);
                } else {
                    timer.count = 0;
                }
            }
        }
    }

    /**
     * 清空
     */
    clear() {
        this.timers.length = 0;
    }
}

/**
 * 根据名获取类，用于通过组件名字获取组件类
 */
export function getClassByName(name: IComponentName) {
    return classManager.getClassByName(name);
}

class ECS implements IECS {
    private entityManager = new EntityManager();
    private systemManager = new SystemManager();
    private componentManager = new ComponentManager();
    private singletons: ISingleton[] = [];

    /**
     * 创建一个基于迭代次数触发的定时器
     */
    public timer() {
        return TimerManager.create();
    }

    /**
     * 查询实体
     */
    public query<T extends IEntity>(filter: Filter): T[];
    public query<T extends IComponent>(filter: Filter, Comment: { new(): T }): T[];
    public query<T>(filter: Filter, Comment?: ITypeofComponent): T[] {
        const entities = Filter.query(this.entityManager, this.componentManager, filter);
        if (!Comment) return entities as T[];
        return entities.map(entity => entity.get(Comment)) as T[];
    }

    /**
     * 查询实体
     */
    public find<T extends IEntity>(filter: Filter): T;
    public find<T extends IComponent>(filter: Filter, Comment: { new(): T }): T;
    public find<T>(filter: Filter, Comment?: ITypeofComponent): T {
        const entity = Filter.find(this.entityManager, this.componentManager, filter);
        if (!entity) return null;
        if (!Comment) return entity as T;
        return entity.get(Comment) as T;
    }

    /**
     * 查询是否存在
     */
    public exist(filter: Filter) {
        return !!Filter.find(this.entityManager, this.componentManager, filter);
    }

    /**
     * 添加单例组件
     */
    public addSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T>;
    public addSingleton<T extends ISingleton>(param: T): T;
    public addSingleton(param: ITypeofSingleton | ISingleton) {
        if (param.ecsName === 'EcsBase') {
            console.error('请使用ecsclass修饰', param);
            return null;
        }
        const com = this.singletons.find(com => com.ecsName === param.ecsName);
        if (com) return com;

        if (param instanceof EcsBase) {
            this.singletons.push(param);
            return param;
        } else {
            const com = new param();
            this.singletons.push(com);
            return com;
        }
    }

    /**
     * 获取单例组件
     */
    public getSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T> {
        return this.singletons.find(com => com.ecsName === param.ecsName) as InstanceType<T>;
    }

    /**
     * 移除单例组件
     */
    public removeSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T> {
        const index = this.singletons.findIndex(com => com.ecsName === param.ecsName);
        if (index >= 0) {
            return this.singletons.splice(index, 1)[0] as InstanceType<T>;
        }
        return null;
    }

    /**
     * 创建一个实体
     */
    public createEntity<T extends ITypeofEntity>(Entity: T, options?: { node?: Node, ecsID?: number }): InstanceType<T> {
        const entity = entityCache.get() || new Entity();
        EcsEntity.init(entity, this, options?.node);
        return entity as InstanceType<T>;
    }

    /**
     * 添加一个实体
     */
    protected addEntity(entity: IEntity) {
        this.entityManager.add(entity);
    }

    /**
     * 移除一个实体
     */
    protected removeEntity(entity: IEntity) {
        this.entityManager.remove(entity);
        if (entity.allowRecycling) {
            EcsBaseEntity.updateUUID(entity);
            entityCache.put(entity);
        }
    }

    /**
     * 添加一个组件
     */
    protected addComponent(entity: EcsEntity, component: IComponent, tag: number | null = null) {
        const result = EcsEntity.addComponent(entity, component, tag);
        if (!result) return false;

        this.componentManager.addComponent(component.ecsName, component);
        return true;
    }

    /**
     * 移除一个组件
     */
    protected removeComponent(component: IComponent, tag: number | null = null) {
        const entity = component.entity;
        const componentName = component.ecsName;

        const result = EcsEntity.removeComponent(entity, component, tag);
        if (!result) return false;

        this.componentManager.removeComponent(componentName, component);
        return true;
    }

    /**
    * 添加一个系统
    */
    public addSystem<T extends ITypeofSystem>(System: T): void {
        const system = new System(this);
        this.systemManager.add(system);
        EcsSystem.onEnable(system);
    }

    /**
     * 移除一个系统
     */
    public removeSystem<T extends ITypeofSystem>(System: T): void {
        const system = this.systemManager.remove(System);
        if (system) EcsSystem.onDisable(system);
    }

    /**
     * 清理所有数据
     */
    public clear() {
        this.systemManager.clear();
        this.entityManager.clear();
        this.componentManager.clear();
        this.singletons.length = 0;
    }

    private executeSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.execute(system, dt, args);
        });
    }
    private beforeExecuteSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.executeWatch(system);
        });
        this.systemManager.each(function (system) {
            EcsSystem.beforeExecute(system, dt, args);
        });
    }
    private afterExecuteSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.afterExecute(system, dt, args);
        });
    }

    private updateSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.update(system, dt, args);
        });
    }
    private beforeUpdateSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.beforeUpdate(system, dt, args);
        });
    }
    private afterUpdateSystem(dt: number, args: any[]) {
        this.systemManager.each(function (system) {
            EcsSystem.afterUpdate(system, dt, args);
        });
    }

    /**
     * 用于手动执行一次render系统(默认会在execute的最后执行)
     */
    public render() {
        this.componentManager.getComponents(RenderComponent.ecsName)?.forEach((render: RenderComponent) => {
            if (!render.enabled) return;
            AttrSystem.inst.innerExecute(render, render.renderNode);
            RenderSystem.inst.innerExecute(render);
        });
    }

    /**
     * 用于逻辑帧
     * 执行顺序:
     * Timer -> Tween -> [自定义系统的beforeExecute] -> Move -> [自定义系统的execute] -> Node ->[自定义系统的afterExecute] ->  Render
     */
    public execute(dt: number, ...args: any[]) {
        // 在execute的最开始执行timer逻辑
        this.componentManager.getComponents(TimerComponent.ecsName)?.forEach((timer: TimerComponent) => {
            if (!timer.enabled) return;
            if (TimerComponent.innerHandle(timer, dt) === 0) {
                timer.destroy();
            }
        });
        // 在execute的最开始执行tween逻辑
        this.componentManager.getComponents(TweenComponent.ecsName)?.forEach((tween: TweenComponent) => {
            if (!tween.enabled) return;
            if (TweenComponent.innerHandle(tween, dt) === 0) {
                tween.destroy();
            }
        });

        this.beforeExecuteSystem(dt, args);

        // 在execute的最后执行move逻辑
        this.componentManager.getComponents(MoveComponent.ecsName)?.forEach((move: MoveComponent) => {
            if (!move.enabled) return;
            MoveSystem.inst.innerExecute(move, dt);
        });

        this.executeSystem(dt, args);

        // 在execute的最后更新node信息
        this.componentManager.getComponents(NodeComponent.ecsName)?.forEach((node: NodeComponent) => {
            if (!node.enabled) return;
            AttrSystem.inst.innerExecute(node);
            NodeComponent.innerHandle(node);
        });

        this.afterExecuteSystem(dt, args);

        // 在execute的最后更新render信息
        this.render();
    }

    /**
     * 用于渲染帧
     * 执行顺序:
     * [自定义系统的beforeUpdate] -> [自定义系统的update] -> [自定义系统的afterUpdate]
     */
    public update(dt: number, ...args: any[]) {
        this.beforeUpdateSystem(dt, args);
        this.updateSystem(dt, args);
        this.afterUpdateSystem(dt, args);
    }
}

class ECSManager extends ECS implements IECSManager {
    private ecsMap: Map<number, IECS> = new Map();

    public getECS(ecsID: number = 0): IECS {
        if (ecsID === 0) {
            return this;
        }
        if (!this.ecsMap.has(ecsID)) {
            this.ecsMap.set(ecsID, new ECS());
        }

        return this.ecsMap.get(ecsID);
    }

    public removeECS(ecsID: number) {
        const ecs = this.ecsMap.get(ecsID);
        if (!ecs) return;
        ecs.clear();
        this.ecsMap.delete(ecsID);
    }

    public clearAll() {
        super.clear();
        this.ecsMap.forEach(ecs => ecs.clear());
        this.ecsMap.clear();
        entityCache.clear();
        componentCache.clear();
        entityUuidMaker.clear();
        systemUuidMaker.clear();
        componentUuidMaker.clear();
        singletonUuidMaker.clear();
    }
}

export const ecs: IECSManager = new ECSManager();

if (DEV && !EDITOR) {
    //@ts-ignore
    window['ecs'] = ecs;
}