import { Node } from 'cc';

/**
 * EcsComponent装饰器
 */
export function ecsclass(className: string) {
    return function fNOP(ctor: any) {
        // ecsName需要先初始化
        (<typeof EcsBase>ctor).ecsName = className;
        classManager.add(ctor, className);
        return ctor;
    };
}

/** 
 * flag位管理器
*/
class FlagManager {
    private index: number = 0;
    private cache: Map<string, IFlag> = new Map();
    private cacheAll: Map<string, IFlag> = new Map();

    /**
     * 在source中添加flag
     * @param source 
     * @param flag 
     */
    addFlag(source: IFlag, flag: IFlag) {
        for (let index = 0; index < flag.length; index++) {
            source[index] |= flag[index];
        }
    }
    /**
     * 在source中移除flag
     * @param source 
     * @param flag 
     */
    removeFlag(source: IFlag, flag: IFlag) {
        for (let index = 0; index < flag.length; index++) {
            source[index] &= ~flag[index];
        }
    }

    /**
     * 检查是否完全包含
     * @param source 源
     * @param sub 子集
     */
    checkFlagAll(source: IFlag, sub: IFlag) {
        for (let index = 0; index < sub.length; index++) {
            if ((source[index] & sub[index]) !== sub[index]) return false;
        }
        return true;
    }
    /**
     * 只包含其中一个即可
     * @param source 源
     * @param sub 子集
     */
    checkFlagAny(source: IFlag, sub: IFlag) {
        for (let index = 0; index < sub.length; index++) {
            if ((source[index] & sub[index]) != 0) return true;
        }
        return false;
    }

    /**
     * 会融合父类
     */
    getAllByName(name: string): IFlag {
        const result = this.cacheAll.get(name);
        if (result) return result;

        const names = [name];
        classManager.eachSuperName(name, (superName) => {
            names.push(superName);
        });

        const flag = this.getByNames(names);
        this.cacheAll.set(name, flag);

        return flag;
    }

    /**
     * 会融合父类
     */
    getAllByNames(names: string[], out: number[]): IFlag {
        // 设置初始值
        let flag = this.getAllByName(names[0]);
        for (let index = 0; index < out.length; index++) {
            out[index] = flag[index];
        }
        // 叠加
        for (let i = 1; i < names.length; i++) {
            flag = this.getAllByName(names[i]);
            for (let index = 0; index < out.length; index++) {
                out[index] = out[index] | flag[index];
            }
        }
        return out;
    }

    /**
     * 只计算自身
     */
    getByName(name: string): IFlag {
        const result = this.cache.get(name);
        if (result) return result;

        const FlagBits = this.bits;

        if (this.index >= FlagBits * 31) {
            throw new Error(`当前Component的种类超过${FlagBits * 31}个`);
        }

        const flag: IFlag = new Array(FlagBits).fill(0);
        flag[(this.index / 31) >>> 0] = (1 << (this.index % 31));
        this.cache.set(name, flag);
        this.index++;

        return flag;
    }

    /**
     * 只计算自身
     */
    getByNames(names: string[]): IFlag {
        const result = new Array(this.bits);
        // 设置初始值
        let flag = this.getByName(names[0]);
        for (let index = 0; index < result.length; index++) {
            result[index] = flag[index];
        }
        // 叠加
        for (let i = 1; i < names.length; i++) {
            flag = this.getByName(names[i]);
            for (let index = 0; index < result.length; index++) {
                result[index] = result[index] | flag[index];
            }
        }
        return result;
    }

    get bits() {
        return Math.ceil(classManager.comSize / 31);
    }
}
export const flagManager = new FlagManager();

/**
 * 类管理器
 */
class ClassManager {
    private comClassCount = 0;
    private nameToSuperName: Map<string, string> = new Map();
    private nameToClass: Map<string, typeof EcsBase> = new Map();
    /**
     * 获取父类
     */
    private getSuper<T extends typeof EcsBase>(type: T): T {
        if (!type || !type.prototype) return null;
        const proto = type.prototype; // binded function do not have prototype
        const dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
    }

    add(ctor: typeof EcsBase, className: string) {
        if (this.nameToClass.has(className)) {
            console.error(`[ecs] ${className}已存在`);
        }
        this.nameToClass.set(className, ctor);

        // 存储类名继承对应关系
        let superCls = this.getSuper(ctor);
        while (superCls && superCls.ecsName !== EcsBase.ecsName) {
            this.nameToSuperName.set(className, superCls.ecsName);
            superCls = this.getSuper(ctor = superCls);
            className = ctor.ecsName;
        }

        if (superCls === EcsBaseComponent) {
            this.comClassCount++;
        } else if (superCls !== EcsBaseSingleton) {
            console.warn('[ecs] 避免用ecsclass修饰系统或实体', className);
        }
    }

    /**
     * 遍历所有父类名
     */
    eachSuperName(subName: string, callback: (superName: string) => any) {
        while (subName) {
            const superName = this.getSuperName(subName);
            if (!superName) break;
            callback(subName = superName);
        }
    }

    /**
     * 通过类名判断一个是否是另一个的子类
     * @param subName 
     * @param superName 
     * @returns 
     */
    isChildByName(subName: string, superName: string) {
        if (!subName) return false;
        if (!superName) return false;

        while (subName) {
            const _superName = this.getSuperName(subName);
            if (_superName === superName) return true;
            subName = _superName;
        }

        return false;
    }

    /**
     * 通过类名获取一个类
     * @param name 
     * @returns 
     */
    getClassByName(name: string) {
        return this.nameToClass.get(name);
    }

    /**
     * 获取父类名字
     */
    getSuperName(name: string) {
        return this.nameToSuperName.get(name) || '';
    }

    /**
     * 组件种类数量
     */
    get comSize() {
        return this.comClassCount;
    }
}
/**类管理器 */
export const classManager = new ClassManager();

class Cache<V> {
    private cache: V[] = [];
    get() {
        if (this.cache.length) {
            return this.cache.pop();
        }
        return null;
    }
    put(v: V) {
        this.cache.push(v);
    }
    clear() {
        this.cache.length = 0;
    }
}
/**实体缓存 */
export const entityCache = new Cache<IEntity>;

class CacheMap<V> {
    private cache: Map<string, V[]> = new Map();
    get(k: string) {
        const array = this.cache.get(k);
        if (array && array.length) {
            return array.pop();
        }
        return null;
    }
    put(k: string, v: V) {
        const array = this.cache.get(k);
        if (array) {
            array.push(v);
        } else {
            this.cache.set(k, [v]);
        }
    }
    clear() {
        this.cache.clear();
    }
}
/**组件缓存 */
export const componentCache = new CacheMap<IComponent>();

/**uuid生成器 */
class UuidMaker {
    private uuid = 0;
    create() {
        return ++this.uuid;
    }
    clear() {
        this.uuid = 0;
    }
}

/**uuid生成器 */
export const entityUuidMaker = new UuidMaker();
export const componentUuidMaker = new UuidMaker();
export const systemUuidMaker = new UuidMaker();
export const singletonUuidMaker = new UuidMaker();

export abstract class EcsBase {
    /**类名 */
    static ecsName = 'EcsBase';
    /**类名 */
    public get ecsName() {
        return (this.constructor as typeof EcsBase).ecsName;
    }
}

/**实体基类 */
export abstract class EcsBaseEntity extends EcsBase {
    static updateUUID(ins: EcsBaseEntity) {
        ins._uuid = entityUuidMaker.create();
    }

    static init(entity: EcsBaseEntity, ecs: IECS, node: Node = null) {
        return entity.innerInit(ecs, node);
    }

    static addComponent(entity: EcsBaseEntity, com: IComponent, tag: number | null = null) {
        return entity.innerAddComponent(com, tag);
    }

    static removeComponent(entity: EcsBaseEntity, com: IComponent, tag: number | null = null) {
        return entity.innerRemoveComponent(com, tag);
    }

    /**唯一ID */
    private _uuid = entityUuidMaker.create();
    public get uuid() {
        return this._uuid;
    }

    /**允许回收复用(默认false) */
    static allowRecycling = false;
    /**允许回收复用(默认false) */
    public get allowRecycling() {
        return (this.constructor as typeof EcsBaseEntity).allowRecycling;
    }

    /**生效*/
    protected abstract onEnable(): any;
    /**失效*/
    protected abstract onDisable(): any;

    /**
     * 内部初始化函数
     */
    protected abstract innerInit(ecs: IECS, node?: Node): any;

    /**
     * 添加组件(内部调用)
     */
    protected abstract innerAddComponent(com: IComponent, tag?: number | null): boolean;

    /**
     * 移除组件(内部调用)
     */
    protected abstract innerRemoveComponent(com: IComponent, tag?: number | null): boolean;
}

/**组件基类 */
export abstract class EcsBaseComponent extends EcsBase {
    static updateUUID(ins: EcsBaseComponent) {
        ins._uuid = componentUuidMaker.create();
    }

    static onEnable(comp: EcsBaseComponent, entity: IEntity, tag: number | null = null) {
        return comp.innerEnable(entity, tag);
    }

    static onDisable(comp: EcsBaseComponent) {
        return comp.innerDisable();
    }

    /**唯一ID */
    private _uuid = componentUuidMaker.create();
    public get uuid() {
        return this._uuid;
    }

    /**允许回收复用(默认false) */
    static allowRecycling = false;
    /**允许回收复用(默认false) */
    public get allowRecycling() {
        return (this.constructor as typeof EcsBaseComponent).allowRecycling;
    }

    /**允许在同一个实体中重复添加(默认false)  */
    static allowMultiple = false;
    /**允许在同一个实体中重复添加(默认false) */
    public get allowMultiple() {
        return (this.constructor as typeof EcsBaseComponent).allowMultiple;
    }

    /**依赖的组件 */
    static requires: ITypeofComponent[] = [];

    /**生效*/
    protected abstract onEnable(): any;
    /**失效*/
    protected abstract onDisable(): any;

    /**
     * 内部生效函数
     */
    protected abstract innerEnable(entity: IEntity, tag: number | null): any;

    /**
     * 内部失效函数
     */
    protected abstract innerDisable(): any;
}

/**系统基类 */
export abstract class EcsBaseSystem extends EcsBase {
    /**唯一ID */
    private _uuid = systemUuidMaker.create();
    public get uuid() {
        return this._uuid;
    }

    static onEnable(system: EcsBaseSystem) {
        system.onEnable();
    }

    static onDisable(system: EcsBaseSystem) {
        system.onDisable();
    }

    static executeWatch(system: EcsBaseSystem) {
        system.executeWatch();
    }

    static execute(system: EcsBaseSystem, dt: number, args: any[]) {
        system.execute(dt, ...args);
    }

    static beforeExecute(system: EcsBaseSystem, dt: number, args: any[]) {
        system.beforeExecute(dt, ...args);
    }

    static afterExecute(system: EcsBaseSystem, dt: number, args: any[]) {
        system.afterExecute(dt, ...args);
    }

    static update(system: EcsBaseSystem, dt: number, args: any[]) {
        system.update(dt, ...args);
    }

    static beforeUpdate(system: EcsBaseSystem, dt: number, args: any[]) {
        system.beforeUpdate(dt, ...args);
    }

    static afterUpdate(system: EcsBaseSystem, dt: number, args: any[]) {
        system.afterUpdate(dt, ...args);
    }

    /**过滤实体的条件 */
    protected abstract filter: IFilter;
    /**开启并配置filter后，才能响应onEntityEnter、onEntityLeave */
    protected abstract openWatchEntities: boolean;

    /**生效*/
    protected abstract onEnable(): any;
    /**失效*/
    protected abstract onDisable(): any;

    /**使用filter进行查询 */
    protected abstract query<T extends IEntity>(): T[];
    protected abstract query<T extends IEntity>(filter: IFilter): T[];
    protected abstract query<T extends IComponent>(filter: IFilter, Comment: { new(): T }): T[];
    protected abstract query<T>(filter?: IFilter, Comment?: ITypeofComponent): T[];

    /**使用filter进行查询 */
    protected abstract find<T extends IEntity>(): T;
    protected abstract find<T extends IEntity>(filter: IFilter): T;
    protected abstract find<T extends IComponent>(filter: IFilter, Comment: { new(): T }): T;
    protected abstract find<T>(filter?: IFilter, Comment?: ITypeofComponent): T;

    /**使用filter进行查询 */
    protected abstract exist(filter?: IFilter): boolean;

    /**实体进入系统，会在execute流程最开始调用*/
    protected abstract onEntityEnter(entities: IEntity[]): any;

    /**实体离开系统，会在execute流程最开始调用*/
    protected abstract onEntityLeave(entities: IEntityUUID[]): any;

    // 由ecs.execute驱动
    protected abstract executeWatch(): any;
    protected abstract execute(dt?: number, ...args: any[]): any;
    protected abstract beforeExecute(dt?: number, ...args: any[]): any;
    protected abstract afterExecute(dt?: number, ...args: any[]): any;

    // 由ecs.update驱动
    protected abstract update(dt?: number, ...args: any[]): any;
    protected abstract beforeUpdate(dt?: number, ...args: any[]): any;
    protected abstract afterUpdate(dt?: number, ...args: any[]): any;
}

/**单例基类 */
export abstract class EcsBaseSingleton extends EcsBase {
    /**唯一ID */
    private _uuid = singletonUuidMaker.create();
    public get uuid() {
        return this._uuid;
    }
}

export type IEntityUUID = number;
export type IComponentName = string;
export type IComponentUUID = number;
export type IFlag = number[];

export type ITypeofEntity = { new(): IEntity, ecsName: string, allowRecycling: boolean };
export type ITypeofComponent = { new(): IComponent, ecsName: string, allowRecycling: boolean, allowMultiple: boolean };
export type ITypeofSystem = { new(ecs: IECS): ISystem, ecsName: string };
export type ITypeofSingleton = { new(): ISingleton, ecsName: string };

export interface IEntity extends EcsBaseEntity {
    /**
     * 是否有效
    */
    readonly isValid: boolean
    /**
     * 创建时绑定的节点
     */
    readonly node: Node
    /**
     * 标记是否生效(为false后将不会被查询到)
     */
    enabled: boolean
    /**
     * 销毁
     * 会在触发onDisable和移除所有组件之后才会isValid设为false
     */
    destroy(): boolean
    /**
     * 杀死
     * 与destroy的区别是，kill会在触发onDisable和移除所有组件之前就将isValid设为false
     */
    kill(): boolean
    /**
     * 检查是否仅包含全部
     */
    checkFlagAll(flag: IFlag): boolean
    /**
     * 检查是否包含任一
     */
    checkFlagAny(flag: IFlag): boolean
    /**
     * 检查是否仅包含全部
     */
    checkFlagOnly(flag: IFlag): boolean
    /**
     * 添加相应类型的组件
     * @see 同add
     * @param param 类型
     * @param tag 标签
     */
    addComponent<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>
    /**
     * 添加相应类型的组件
     * @param param 类型
     * @param tag 标签
     * @returns 
     */
    add<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>
    /**
     * 移除相应类型的第一个组件
     * @see 同remove
     * @param param 类型
     * @param tag 标签
     */
    removeComponent(Com: ITypeofComponent | IComponent, tag?: number): boolean
    /**
     * 移除相应类型的第一个组件
     * @param param 类型
     * @param tag 标签
     */
    remove(Com: ITypeofComponent | IComponent, tag?: number): boolean
    /**
     * 移除相应组件的所有组件
     * @see 同removeAll
     * @param Com 类型
     * @param tag 标签
     */
    removeComponents(Com: ITypeofComponent, tag?: number): boolean;
    /**
     * 移除相应组件的所有组件
     * @param Com 类型
     * @param tag 标签
     * @returns 
     */
    removeAll(Com: ITypeofComponent, tag?: number): boolean;
    /**
     * 有没有相应类型的组件(绑定权柄的组件也能获取到)
     * @see 同has
     */
    hasComponent(Com: ITypeofComponent, tag?: number): boolean
    /**
     * 有没有相应类型的组件(绑定权柄的组件也能获取到)
     */
    has(Com: ITypeofComponent, tag?: number): boolean
    /**
     * 获取相应类型的组件(绑定权柄的组件也能获取到)
     * @see 同get
     */
    getComponent<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>
    /**
     * 获取相应类型的组件(绑定权柄的组件也能获取到)
     */
    get<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>
    /**
     * 获取相应类型的组件(绑定权柄的组件也能获取到)
     * @see 同getAll
     */
    getComponents<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>[]
    /**
     * 获取相应类型的组件(绑定权柄的组件也能获取到)
     */
    getAll<T extends ITypeofComponent>(Com: T, tag?: number): InstanceType<T>[]
}

export interface IComponent<E extends IEntity = IEntity> extends EcsBaseComponent {
    /**是否有效*/
    readonly isValid: boolean
    /**
     * 标记是否生效(为false后将不会被查询到)
     */
    enabled: boolean
    /**当前组件所在的实体 */
    readonly entity: E;
    /**当前组件的标签，默认为null */
    readonly tag: number | null;
    /**销毁当前组件 */
    destroy(tag?: number): boolean;
}

export type ISystem = EcsBaseSystem;

export type ISingleton = EcsBaseSingleton;

export interface IFilter {
    /**
     * 有这些组件中的任何一个
     */
    any(...args: ITypeofComponent[]): this
    /**
     * 必须包含所有这些组件
     */
    all(...args: ITypeofComponent[]): this
    /**
     * 仅仅只有这些组件
     */
    only(...args: ITypeofComponent[]): this
    /**
     * 不能包含其中的任何一个组件
     */
    exclude(...args: ITypeofComponent[]): this
}

export interface IECS {
    /**添加系统 */
    addSystem<T extends ITypeofSystem>(System: T): void
    /**移除系统 */
    removeSystem<T extends ITypeofSystem>(System: T): void
    /**添加单例组件 */
    addSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T>
    /**添加单例组件 */
    addSingleton<T extends ISingleton>(param: T): T
    /**获取单例组件 */
    getSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T>
    /**移除单例组件 */
    removeSingleton<T extends ITypeofSingleton>(param: T): InstanceType<T>
    /**创建一个实体 */
    createEntity<T extends ITypeofEntity>(Entity: T, options?: { node?: Node, ecsID?: number }): InstanceType<T>
    /**清理系统、实体、组件、单例组件(都不会触发生命周期) */
    clear(): any
    /**用于手动执行一次render系统(默认会在execute的最后执行) */
    render(): any
    /**一般由游戏循环驱动 */
    execute(dt: number, ...args: any[]): any
    /**等同于execute，一般情况下用不到，比如当需要区分逻辑帧与渲染帧时，用于渲染帧 */
    update(dt: number, ...args: any[]): any
}

export interface IECSManager extends IECS {
    /**
     * 根据ID获取一个ECS实例
     */
    getECS(ecsID: number): IECS
    /**
     * 移除一个ECS实例
     */
    removeECS(ecsID: number): void
    /**
     * 清理所有内存
     */
    clearAll(): void
}