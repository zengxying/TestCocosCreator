
/**
 * Map、Set、Array都是有序的
 */
class ListItem<T> {
    static cache: ListItem<any>[] = [];
    static create<T>(value: T = null) {
        if (this.cache.length) {
            const list = this.cache.pop();
            list.value = value;
            return list;
        }
        return new ListItem(value);
    }
    static put<T>(list: ListItem<T>) {
        list.value = null;
        list.next = null;
        this.cache.push(list);
    }

    next: ListItem<T> = null;
    value: T = null;
    private constructor(value: T = null) {
        this.value = value;
    }
}
export class CustomList<T>{
    private head: ListItem<T> = ListItem.create();
    private tail: ListItem<T> = this.head;
    private count = 0;

    get size() {
        return this.count;
    }
    values(out: T[]) {
        let item = this.head.next;
        while (item) {
            out.push(item.value);
            item = item.next;
        }
        return out;
    }
    has(value: T) {
        let item = this.head.next;
        while (item) {
            if (item.value === value) {
                return true;
            }
            item = item.next;
        }
        return false;
    }
    add(value: T) {
        this.count++;
        this.tail.next = ListItem.create(value);
        this.tail = this.tail.next;
        return this.count;
    }
    remove(value: T) {
        let item = this.head;
        while (item.next) {
            if (item.next.value === value) {
                this.count--;
                const removed = item.next;
                item.next = removed.next;
                if (item.next === null) {
                    this.tail = item;
                }
                ListItem.put(removed);
                return true;
            }
            item = item.next;
        }
        return false;
    }
    forEach(callbackfn: (value: T) => void, thisArg?: any) {
        let item = this.head.next;
        while (item) {
            callbackfn.call(thisArg, item.value);
            item = item.next;
        }
    }
    clear() {
        let curr = this.head.next;
        let next = curr && curr.next;
        while (curr) {
            ListItem.put(curr);
            curr = next;
            next = curr && curr.next;
        }

        this.head.next = null;
        this.tail = this.head;
        this.count = 0;
    }
}
export class CustomArray<T>{
    private array: T[] = [];

    get size() {
        return this.array.length;
    }
    values(out: T[]) {
        Array.prototype.push.apply(out, this.array);
        return out;
    }
    get(index: number) {
        return this.array[index];
    }
    has(value: T) {
        return this.array.indexOf(value) >= 0;
    }
    add(value: T) {
        this.array.push(value);
    }
    remove(value: T) {
        const index = this.array.indexOf(value);
        if (index >= 0) {
            this.array.splice(index, 1);
            return true;
        }
        return false;
    }
    forEach(callbackfn: (value: T, index: number, array: T[]) => void, thisArg?: any) {
        return this.array.forEach(callbackfn, thisArg);
    }
    find(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) {
        return this.array.find(callbackfn, thisArg);
    }
    findIndex(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) {
        return this.array.findIndex(callbackfn, thisArg);
    }
    some(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) {
        return this.array.some(callbackfn, thisArg);
    }
    every(callbackfn: (value: T, index: number, array: T[]) => boolean, thisArg?: any) {
        return this.array.every(callbackfn, thisArg);
    }
    clear() {
        this.array.length = 0;
    }
}

export class CustomMap<K, V> {
    private map: Map<K, V> = new Map();

    get size() {
        return this.map.size;
    }
    keys(out: K[]) {
        this.map.forEach((v, key) => out.push(key));
        return out;
    }
    values(out: V[]) {
        this.map.forEach((value) => out.push(value));
        return out;
    }
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any) {
        return this.map.forEach(callbackfn, thisArg);
    }
    get(key: K) {
        return this.map.get(key);
    }
    has(key: K) {
        return this.map.has(key);
    }
    set(key: K, value: V) {
        return this.map.set(key, value);
    }
    delete(key: K) {
        return this.map.delete(key);
    }
    clear() {
        this.map.clear();
    }
}

export class NumberMap<K> extends CustomMap<K, number> {
    add(key: K) {
        const num = (this.get(key) || 0) + 1;
        this.set(key, num);
        return num;
    }
    sub(key: K) {
        if (!this.has(key)) return 0;
        const num = this.get(key) - 1;
        this.set(key, num);
        return num;
    }
    subDel(key: K) {
        if (this.sub(key) === 0) {
            this.delete(key);
            return true;
        }
        return false;
    }
}

/**
 * 数组Map
 */
export class ArrayMap<K, V> extends CustomMap<K, Array<V>> {
    add(key: K, value: V) {
        if (!this.has(key)) {
            this.set(key, [value]);
            return 1;
        } else {
            const array = this.get(key);
            array.push(value);
            return array.length;
        }
    }
    sub(key: K, value: V) {
        const array = this.get(key);
        if (!array) {
            return 0;
        }
        const index = array.indexOf(value);
        if (index >= 0) {
            array.splice(index, 1);
        }

        return array.length;
    }
    subDel(key: K, value: V) {
        if (this.sub(key, value) === 0) {
            this.delete(key);
            return true;
        }
        return false;
    }
}

export class SetMap<K, V> extends CustomMap<K, Set<V>> {
    add(key: K, value: V) {
        if (!this.has(key)) {
            return this.set(key, new Set<V>().add(value)).size;
        } else {
            return this.get(key).add(value).size;
        }
    }
    sub(key: K, value: V) {
        if (!this.has(key)) return 0;
        const set = this.get(key);
        set.delete(value);
        return set.size;
    }
    subDel(key: K, value: V) {
        if (this.sub(key, value) === 0) {
            this.delete(key);
            return true;
        }
        return false;
    }
}

/**
 * 唯一数组(同Set)Map
 */
export class UArrayMap<K, V> extends ArrayMap<K, V> {
    add(key: K, value: V) {
        if (!this.has(key)) {
            this.set(key, [value]);
            return 1;
        } else {
            const array = this.get(key);
            if (array.indexOf(value) === -1) {
                array.push(value);
            }
            return array.length;
        }
    }
}

/**
 * 唯一List(同Set)Map
 */
export class UListMap<K, V> extends CustomMap<K, CustomList<V>> {
    add(key: K, value: V) {
        if (!this.has(key)) {
            const list = new CustomList<V>();
            this.set(key, list);
            list.add(value);
            return 1;
        } else {
            const list = this.get(key);
            if (!list.has(value)) {
                list.add(value);
            }
            return list.size;
        }
    }
    sub(key: K, value: V) {
        if (!this.has(key)) return 0;

        const list = this.get(key);
        list.remove(value);

        return list.size;
    }
    subDel(key: K, value: V) {
        if (this.sub(key, value) === 0) {
            this.delete(key);
            return true;
        }
        return false;
    }
}

export function createMap(forceDictMode: boolean) {
    let map = Object.create(null);
    if (forceDictMode) {
        const INVALID_IDENTIFIER_1 = '.';
        const INVALID_IDENTIFIER_2 = '/';
        map[INVALID_IDENTIFIER_1] = true;
        map[INVALID_IDENTIFIER_2] = true;
        delete map[INVALID_IDENTIFIER_1];
        delete map[INVALID_IDENTIFIER_2];
    }
    return map;
}

/**
 * 过滤原数组，性能高但是会改变原属组的顺序
 */
export function filterArray<T>(array: Array<T>, filter: (item: T) => boolean) {
    let index = 0,
        item: T = null,
        length = array.length;
    while (index < length) {
        item = array[index];
        if (filter(item)) {
            ++index;
        } else {
            array[index] = array[length - 1];
            array[length - 1] = item;
            --length;
        }
    }
    array.length = length;
}